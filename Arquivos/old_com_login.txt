import streamlit as st
import sqlite3
import pandas as pd
from pathlib import Path
from datetime import date, datetime, timedelta
import json
import plotly.express as px
import calendar
import hashlib
import re
import os
import traceback

os.system('clear' if os.name == 'posix' else 'cls')

# ---------- Configura√ß√µes ----------
DB_FILE = Path("financeiro.db")
EXCEL_APOIO = Path("Renda_2026.xlsx")
APOIO_SHEET = "Planilha apoio"
CONFIG_FILE = Path("config.json")

# ---------- Sistema de Autentica√ß√£o Melhorado ----------
class SistemaAutenticacao:
    def __init__(self, db_file="financeiro.db"):
        self.db_file = db_file
        self._verificar_e_atualizar_estrutura_banco()
        self._criar_admin_padrao()
    
    def _verificar_e_atualizar_estrutura_banco(self):
        """Verifica e atualiza a estrutura do banco de dados"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        # 1. Criar tabela de usu√°rios se n√£o existir
        cur.execute("""
            CREATE TABLE IF NOT EXISTS usuarios (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                senha_hash TEXT NOT NULL,
                tipo TEXT NOT NULL DEFAULT 'COMUM',
                nome TEXT,
                email TEXT,
                ativo INTEGER DEFAULT 1,
                grupo TEXT DEFAULT 'padrao',
                compartilhado INTEGER DEFAULT 1,
                pode_compartilhar INTEGER DEFAULT 0,
                data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                data_ultimo_login TIMESTAMP
            )
        """)
        
        # 2. Verificar e adicionar colunas faltantes
        colunas_necessarias = [
            ('grupo', 'TEXT DEFAULT "padrao"'),
            ('compartilhado', 'INTEGER DEFAULT 1'),
            ('pode_compartilhar', 'INTEGER DEFAULT 0'),
            ('data_criacao', 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'),
            ('data_ultimo_login', 'TIMESTAMP')
        ]
        
        # Obter colunas existentes
        cur.execute("PRAGMA table_info(usuarios)")
        colunas_existentes = [col[1] for col in cur.fetchall()]
        
        # Adicionar colunas faltantes
        for coluna, definicao in colunas_necessarias:
            if coluna not in colunas_existentes:
                try:
                    cur.execute(f"ALTER TABLE usuarios ADD COLUMN {coluna} {definicao}")
                    print(f"Coluna {coluna} adicionada √† tabela usuarios")
                except sqlite3.OperationalError as e:
                    print(f"Erro ao adicionar coluna {coluna}: {e}")
        
        # 3. Criar tabela de logs
        cur.execute("""
            CREATE TABLE IF NOT EXISTS logs_acesso (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                usuario_id INTEGER,
                acao TEXT,
                descricao TEXT,
                data_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
            )
        """)
        
        # 4. Criar tabela de transa√ß√µes se n√£o existir
        cur.execute("""
            CREATE TABLE IF NOT EXISTS transacoes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                data_registro DATE,
                data_pagamento DATE,
                pessoa TEXT,
                categoria TEXT,
                tipo TEXT,
                valor REAL,
                descricao TEXT,
                recorrente INTEGER DEFAULT 0,
                dia_fixo INTEGER,
                pessoa_responsavel TEXT DEFAULT 'Ambos',
                no_cartao INTEGER DEFAULT 0,
                investimento INTEGER DEFAULT 0,
                vr INTEGER DEFAULT 0,
                forma_pagamento TEXT DEFAULT 'Dinheiro',
                parcelas INTEGER DEFAULT 1,
                parcela_atual INTEGER DEFAULT 1,
                status TEXT DEFAULT 'Ativa',
                usuario_id INTEGER,
                grupo TEXT DEFAULT 'padrao',
                compartilhado INTEGER DEFAULT 0,
                FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
            )
        """)
        
        # 5. Verificar colunas faltantes na tabela transacoes
        cur.execute("PRAGMA table_info(transacoes)")
        colunas_transacoes = [col[1] for col in cur.fetchall()]
        
        colunas_transacoes_necessarias = [
            ('usuario_id', 'INTEGER'),
            ('grupo', 'TEXT DEFAULT "padrao"'),
            ('compartilhado', 'INTEGER DEFAULT 0'),
            ('status', 'TEXT DEFAULT "Ativa"')
        ]
        
        for coluna, definicao in colunas_transacoes_necessarias:
            if coluna not in colunas_transacoes:
                try:
                    cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} {definicao}")
                    print(f"Coluna {coluna} adicionada √† tabela transacoes")
                except sqlite3.OperationalError:
                    pass
        
        conn.commit()
        conn.close()
        
        # 6. Migrar dados existentes
        self._migrar_dados_existentes()
    
    def _migrar_dados_existentes(self):
        """Migra dados existentes para a nova estrutura"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            # Migrar transa√ß√µes antigas para o usu√°rio admin
            cur.execute("SELECT COUNT(*) FROM transacoes WHERE usuario_id IS NULL")
            count = cur.fetchone()[0]
            
            if count > 0:
                # Obter ID do admin
                cur.execute("SELECT id FROM usuarios WHERE username = 'admin' AND tipo = 'ADM'")
                admin = cur.fetchone()
                
                if admin:
                    admin_id = admin[0]
                    cur.execute("""
                        UPDATE transacoes 
                        SET usuario_id = ?, grupo = 'padrao', compartilhado = 1
                        WHERE usuario_id IS NULL
                    """, (admin_id,))
                    conn.commit()
                    print(f"‚úÖ {count} transa√ß√µes migradas para o usu√°rio admin")
            
            # Atualizar usu√°rios sem grupo
            cur.execute("UPDATE usuarios SET grupo = 'padrao' WHERE grupo IS NULL")
            cur.execute("UPDATE usuarios SET compartilhado = 1 WHERE compartilhado IS NULL")
            
            conn.commit()
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na migra√ß√£o: {e}")
        finally:
            conn.close()
    
    def _criar_admin_padrao(self):
        """Cria usu√°rio administrador padr√£o se n√£o existir"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            cur.execute("SELECT COUNT(*) FROM usuarios WHERE username = 'admin'")
            count = cur.fetchone()[0]
            
            if count == 0:
                # Senha padr√£o: admin123
                senha_hash = self._hash_senha("admin123")
                cur.execute("""
                    INSERT INTO usuarios (username, senha_hash, tipo, nome, email, grupo, compartilhado, pode_compartilhar)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, ("admin", senha_hash, "ADM", "Administrador", "admin@financeiro.com", "admin", 1, 1))
                
                conn.commit()
                print("‚úÖ Usu√°rio administrador padr√£o criado: admin / admin123")
            else:
                # Verificar se o admin tem senha atualizada
                cur.execute("SELECT senha_hash FROM usuarios WHERE username = 'admin'")
                senha_hash_atual = cur.fetchone()[0]
                
                # Se a senha ainda for a padr√£o (admin123), avisar para alterar
                senha_padrao_hash = self._hash_senha("admin123")
                if senha_hash_atual == senha_padrao_hash:
                    print("‚ö†Ô∏è ATEN√á√ÉO: Usu√°rio admin ainda est√° com senha padr√£o 'admin123'")
                    
        except Exception as e:
            print(f"Erro ao criar admin padr√£o: {e}")
        finally:
            conn.close()
    
    def _hash_senha(self, senha):
        """Gera hash da senha usando SHA-256 com salt"""
        salt = "financeiro_familiar_2025"
        return hashlib.sha256((senha + salt).encode()).hexdigest()
    
    def validar_senha(self, senha):
        """Valida for√ßa da senha"""
        if len(senha) < 8:
            return False, "A senha deve ter pelo menos 8 caracteres"
        
        if not re.search(r"[A-Z]", senha):
            return False, "A senha deve conter pelo menos uma letra mai√∫scula"
        
        if not re.search(r"[a-z]", senha):
            return False, "A senha deve conter pelo menos uma letra min√∫scula"
        
        if not re.search(r"\d", senha):
            return False, "A senha deve conter pelo menos um n√∫mero"
        
        # Opcional: adicionar caractere especial
        # if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", senha):
        #     return False, "A senha deve conter pelo menos um caractere especial"
        
        return True, "Senha v√°lida"
    
    def autenticar(self, username, senha):
        """Autentica usu√°rio e retorna dados se v√°lido"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            # Buscar usu√°rio
            cur.execute("""
                SELECT id, username, senha_hash, tipo, nome, grupo, compartilhado 
                FROM usuarios 
                WHERE username = ? AND ativo = 1
            """, (username,))
            
            usuario = cur.fetchone()
            
            if not usuario:
                return False, None, "Usu√°rio n√£o encontrado ou inativo"
            
            # Verificar senha
            senha_hash = self._hash_senha(senha)
            if usuario[2] != senha_hash:
                return False, None, "Senha incorreta"
            
            # Atualizar data do √∫ltimo login
            cur.execute("""
                UPDATE usuarios 
                SET data_ultimo_login = CURRENT_TIMESTAMP 
                WHERE id = ?
            """, (usuario[0],))
            
            # Dados do usu√°rio
            user_data = {
                'id': usuario[0],
                'username': usuario[1],
                'tipo': usuario[3],
                'nome': usuario[4],
                'grupo': usuario[5] or 'padrao',
                'compartilhado': usuario[6] or 0
            }
            
            # Log de acesso
            cur.execute("""
                INSERT INTO logs_acesso (usuario_id, acao, descricao)
                VALUES (?, 'LOGIN', 'Login realizado com sucesso')
            """, (usuario[0],))
            
            conn.commit()
            return True, user_data, "Login realizado com sucesso"
            
        except sqlite3.OperationalError as e:
            error_msg = str(e)
            if "no such column" in error_msg:
                # Recriar estrutura do banco se houver erro de coluna
                self._verificar_e_atualizar_estrutura_banco()
                return False, None, "Estrutura do banco atualizada. Tente novamente."
            return False, None, f"Erro na autentica√ß√£o: {error_msg}"
        except Exception as e:
            return False, None, f"Erro na autentica√ß√£o: {str(e)}"
        finally:
            conn.close()
    
    def alterar_senha(self, username, senha_atual, nova_senha):
        """Altera a senha do usu√°rio"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            # Verificar senha atual
            cur.execute("SELECT id, senha_hash FROM usuarios WHERE username = ?", (username,))
            usuario = cur.fetchone()
            
            if not usuario:
                return False, "Usu√°rio n√£o encontrado"
            
            senha_hash_atual = self._hash_senha(senha_atual)
            if usuario[1] != senha_hash_atual:
                return False, "Senha atual incorreta"
            
            # Validar nova senha
            valido, mensagem = self.validar_senha(nova_senha)
            if not valido:
                return False, mensagem
            
            # Atualizar senha
            nova_senha_hash = self._hash_senha(nova_senha)
            cur.execute("""
                UPDATE usuarios 
                SET senha_hash = ? 
                WHERE id = ?
            """, (nova_senha_hash, usuario[0]))
            
            # Log
            cur.execute("""
                INSERT INTO logs_acesso (usuario_id, acao, descricao)
                VALUES (?, 'ALTERACAO_SENHA', 'Senha alterada com sucesso')
            """, (usuario[0],))
            
            conn.commit()
            return True, "Senha alterada com sucesso"
            
        except Exception as e:
            return False, f"Erro ao alterar senha: {str(e)}"
        finally:
            conn.close()
    
    def listar_usuarios(self):
        """Lista todos os usu√°rios"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        cur.execute("""
            SELECT id, username, tipo, nome, email, ativo, grupo, compartilhado,
                   data_criacao, data_ultimo_login
            FROM usuarios
            ORDER BY tipo DESC, username
        """)
        
        usuarios = cur.fetchall()
        colunas = [desc[0] for desc in cur.description]
        conn.close()
        
        return usuarios, colunas
    
    def alterar_status_usuario(self, usuario_id, ativo):
        """Ativa/desativa um usu√°rio"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            cur.execute("""
                UPDATE usuarios 
                SET ativo = ? 
                WHERE id = ?
            """, (1 if ativo else 0, usuario_id))
            
            # Log
            status = "ativado" if ativo else "desativado"
            cur.execute("""
                INSERT INTO logs_acesso (usuario_id, acao, descricao)
                VALUES (?, 'ALTERACAO_STATUS', 'Usu√°rio ' || ?)
            """, (usuario_id, status))
            
            conn.commit()
            return True, f"Usu√°rio {status} com sucesso"
            
        except Exception as e:
            return False, f"Erro ao alterar status: {str(e)}"
        finally:
            conn.close()
    
    def alterar_tipo_usuario(self, usuario_id, novo_tipo):
        """Altera o tipo de usu√°rio (ADM/COMUM)"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            cur.execute("""
                UPDATE usuarios 
                SET tipo = ? 
                WHERE id = ?
            """, (novo_tipo, usuario_id))
            
            # Log
            cur.execute("""
                INSERT INTO logs_acesso (usuario_id, acao, descricao)
                VALUES (?, 'ALTERACAO_TIPO', 'Tipo alterado para ' || ?)
            """, (usuario_id, novo_tipo))
            
            conn.commit()
            return True, f"Tipo de usu√°rio alterado para {novo_tipo}"
            
        except Exception as e:
            return False, f"Erro ao alterar tipo: {str(e)}"
        finally:
            conn.close()
    
    def alterar_grupo_usuario(self, usuario_id, novo_grupo, novo_compartilhado):
        """Altera o grupo e status de compartilhamento do usu√°rio"""
        conn = sqlite3.connect(self.db_file)
        cur = conn.cursor()
        
        try:
            cur.execute("""
                UPDATE usuarios 
                SET grupo = ?, compartilhado = ?
                WHERE id = ?
            """, (novo_grupo, novo_compartilhado, usuario_id))
            
            # Log
            compartilhado_str = "compartilhado" if novo_compartilhado else "separado"
            cur.execute("""
                INSERT INTO logs_acesso (usuario_id, acao, descricao)
                VALUES (?, 'ALTERACAO_GRUPO', 'Grupo alterado para ' || ? || ' (' || ? || ')')
            """, (usuario_id, novo_grupo, compartilhado_str))
            
            conn.commit()
            return True, f"Grupo alterado para {novo_grupo} ({compartilhado_str})"
            
        except Exception as e:
            return False, f"Erro ao alterar grupo: {str(e)}"
        finally:
            conn.close()

# ---------- Instanciar sistema de autentica√ß√£o ----------
auth = SistemaAutenticacao()

# ---------- Fun√ß√µes auxiliares ----------
def load_config():
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    return {"dia_fatura": 10}

def save_config(conf: dict):
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(conf, f, ensure_ascii=False, indent=2)

config = load_config()

# ---------- Datas ----------
def ajustar_para_fatura(data_compra, dia_fatura=10):
    if data_compra.month == 12:
        return date(data_compra.year + 1, 1, dia_fatura)
    else:
        return date(data_compra.year, data_compra.month + 1, dia_fatura)

# ---------- Banco ----------
def get_conn():
    conn = sqlite3.connect(str(DB_FILE), detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)
    return conn

def ensure_tables_exist():
    conn = get_conn()
    cur = conn.cursor()
    
    # Tabela de transa√ß√µes
    cur.execute("""
        CREATE TABLE IF NOT EXISTS transacoes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            data_registro DATE,
            data_pagamento DATE,
            pessoa TEXT,
            categoria TEXT,
            tipo TEXT,
            valor REAL,
            descricao TEXT,
            recorrente INTEGER DEFAULT 0,
            dia_fixo INTEGER,
            pessoa_responsavel TEXT DEFAULT 'Ambos',
            no_cartao INTEGER DEFAULT 0,
            investimento INTEGER DEFAULT 0,
            vr INTEGER DEFAULT 0,
            forma_pagamento TEXT DEFAULT 'Dinheiro',
            parcelas INTEGER DEFAULT 1,
            parcela_atual INTEGER DEFAULT 1,
            status TEXT DEFAULT 'Ativa',
            usuario_id INTEGER,
            grupo TEXT DEFAULT 'padrao',
            compartilhado INTEGER DEFAULT 0,
            FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
        )
    """)
    
    # Verificar e adicionar colunas ausentes se necess√°rio
    colunas_necessarias = [
        'data_registro', 'data_pagamento', 'parcelas', 'parcela_atual', 'status',
        'usuario_id', 'grupo', 'compartilhado'
    ]
    
    for coluna in colunas_necessarias:
        try:
            if coluna == 'status':
                cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} TEXT DEFAULT 'Ativa'")
            elif coluna == 'usuario_id':
                cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} INTEGER")
            elif coluna == 'grupo':
                cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} TEXT DEFAULT 'padrao'")
            elif coluna == 'compartilhado':
                cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} INTEGER DEFAULT 0")
            elif coluna in ['data_registro', 'data_pagamento']:
                cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} DATE")
            else:
                cur.execute(f"ALTER TABLE transacoes ADD COLUMN {coluna} INTEGER DEFAULT 1")
        except sqlite3.OperationalError:
            pass  # Coluna j√° existe
    
    conn.commit()
    conn.close()

def inserir_transacao(tipo, data_registro, data_pagamento, descricao, valor, categoria, forma, extra_fields=None, usuario_id=None):
    pessoa = "Ambos"
    recorrente = 0
    dia_fixo = None
    pessoa_responsavel = "Ambos"
    no_cartao = 1 if ("cred" in forma.lower() or "cart" in forma.lower()) else 0
    investimento = 0
    vr = 0
    parcelas = 1
    parcela_atual = 1

    if extra_fields:
        recorrente = int(extra_fields.get("recorrente", recorrente))
        dia_fixo = extra_fields.get("dia_fixo", dia_fixo)
        pessoa_responsavel = extra_fields.get("pessoa_responsavel", pessoa_responsavel)
        no_cartao = int(extra_fields.get("no_cartao", no_cartao))
        investimento = int(extra_fields.get("investimento", investimento))
        vr = int(extra_fields.get("vr", vr))
        parcelas = int(extra_fields.get("parcelas", parcelas))
        parcela_atual = int(extra_fields.get("parcela_atual", parcela_atual))

    conn = get_conn()
    cur = conn.cursor()
    
    # Buscar informa√ß√µes do usu√°rio
    grupo_usuario = "padrao"
    compartilhado_usuario = 0
    
    if usuario_id:
        cur.execute("SELECT grupo, compartilhado FROM usuarios WHERE id = ?", (usuario_id,))
        resultado = cur.fetchone()
        if resultado:
            grupo_usuario = resultado[0] if resultado[0] else "padrao"
            compartilhado_usuario = resultado[1] if resultado[1] else 0
    
    # Determinar compartilhamento baseado no usu√°rio
    compartilhado = compartilhado_usuario

    cur.execute("""
        INSERT INTO transacoes (
            data_registro, data_pagamento, pessoa, categoria, tipo, valor, descricao, 
            recorrente, dia_fixo, pessoa_responsavel, no_cartao, investimento, vr, 
            forma_pagamento, parcelas, parcela_atual, status, usuario_id, grupo, compartilhado
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        data_registro.isoformat(), data_pagamento.isoformat(), pessoa, categoria, tipo, 
        float(valor), descricao, recorrente, dia_fixo, pessoa_responsavel, no_cartao, 
        investimento, vr, forma, parcelas, parcela_atual, 'Ativa', usuario_id, grupo_usuario, compartilhado
    ))
    
    conn.commit()
    conn.close()

def carregar_transacoes(usuario_id=None):
    conn = get_conn()
    try:
        # Primeiro, verificar se o usu√°rio existe e pegar seus dados
        cur = conn.cursor()
        usuario_tipo = None
        usuario_grupo = None
        usuario_compartilhado = None
        
        if usuario_id:
            cur.execute("SELECT tipo, grupo, compartilhado FROM usuarios WHERE id = ?", (usuario_id,))
            resultado = cur.fetchone()
            if resultado:
                usuario_tipo = resultado[0]
                usuario_grupo = resultado[1] if resultado[1] else "padrao"
                usuario_compartilhado = resultado[2]
        
        # Construir query base
        query = """
            SELECT t.*, u.username as usuario_nome 
            FROM transacoes t
            LEFT JOIN usuarios u ON t.usuario_id = u.id
            WHERE (t.status != 'Exclu√≠da' OR t.status IS NULL)
        """
        params = []
        
        # Se n√£o for ADM, aplicar filtros
        if usuario_tipo != "ADM":
            if usuario_compartilhado == 1:
                # Usu√°rio com base compartilhada: ver transa√ß√µes do mesmo grupo
                query += " AND t.grupo = ?"
                params.append(usuario_grupo)
            else:
                # Usu√°rio com base separada: ver apenas suas transa√ß√µes
                query += " AND t.usuario_id = ?"
                params.append(usuario_id)
        
        query += " ORDER BY t.data_pagamento DESC, t.id DESC"
        
        df = pd.read_sql_query(query, conn, params=params)
        
        if not df.empty:
            date_columns = ['data_registro', 'data_pagamento']
            for col in date_columns:
                if col in df.columns:
                    df[col] = pd.to_datetime(df[col], errors='coerce')
        
        return df
    except Exception as e:
        st.error(f"Erro ao carregar transa√ß√µes: {e}")
        st.error(traceback.format_exc())
        return pd.DataFrame()
    finally:
        conn.close()

# ---------- Fun√ß√µes principais ----------
def processar_recorrencias_automaticas(usuario_id=None):
    conn = get_conn()
    cur = conn.cursor()
    
    query = """
        SELECT t.*, u.grupo, u.compartilhado
        FROM transacoes t
        LEFT JOIN usuarios u ON t.usuario_id = u.id
        WHERE t.recorrente = 1 
        AND (t.status IS NULL OR t.status != 'Exclu√≠da')
    """
    params = []
    
    if usuario_id:
        query += " AND t.usuario_id = ?"
        params.append(usuario_id)
    
    cur.execute(query, params)
    transacoes_recorrentes = cur.fetchall()
    
    cur.execute("PRAGMA table_info(transacoes)")
    colunas_info = cur.fetchall()
    colunas = [col[1] for col in colunas_info]
    colunas.append('grupo_usuario')
    colunas.append('compartilhado_usuario')
    
    hoje = date.today()
    novas_transacoes = 0
    
    for transacao in transacoes_recorrentes:
        transacao_dict = dict(zip(colunas, transacao))
        
        data_registro_original = transacao_dict['data_registro']
        data_pagamento_original = transacao_dict['data_pagamento']
        descricao_original = transacao_dict['descricao']
        dia_fixo = transacao_dict.get('dia_fixo')
        valor = transacao_dict['valor']
        categoria = transacao_dict['categoria']
        tipo = transacao_dict['tipo']
        forma_pagamento = transacao_dict['forma_pagamento']
        no_cartao = transacao_dict.get('no_cartao', 0)
        usuario_id_trans = transacao_dict.get('usuario_id')
        grupo_usuario = transacao_dict.get('grupo_usuario', 'padrao')
        compartilhado_usuario = transacao_dict.get('compartilhado_usuario', 0)
        
        if isinstance(data_registro_original, str):
            try:
                data_registro_original = date.fromisoformat(data_registro_original)
            except:
                data_registro_original = date.today()
        if isinstance(data_pagamento_original, str):
            try:
                data_pagamento_original = date.fromisoformat(data_pagamento_original)
            except:
                data_pagamento_original = date.today()
        
        if not dia_fixo:
            dia_fixo = data_pagamento_original.day if data_pagamento_original else 1
        
        try:
            meses_passados = (hoje.year - data_pagamento_original.year) * 12 + (hoje.month - data_pagamento_original.month)
        except:
            meses_passados = 0
        
        for meses in range(1, meses_passados + 1):
            ano = data_pagamento_original.year + (data_pagamento_original.month + meses - 1) // 12
            mes_num = (data_pagamento_original.month + meses - 1) % 12 + 1
            
            try:
                ultimo_dia_mes = calendar.monthrange(ano, mes_num)[1]
                dia = min(int(dia_fixo), ultimo_dia_mes)
                
                data_pagamento_virtual = date(ano, mes_num, dia)
                
                if data_pagamento_virtual <= hoje and data_pagamento_virtual > data_pagamento_original:
                    cur.execute("""
                        SELECT COUNT(*) FROM transacoes 
                        WHERE descricao LIKE ? 
                        AND strftime('%Y-%m', data_pagamento) = ?
                        AND recorrente = 1
                        AND usuario_id = ?
                    """, (f"%{descricao_original}%", data_pagamento_virtual.strftime('%Y-%m'), usuario_id_trans))
                    
                    existe = cur.fetchone()[0]
                    
                    if not existe:
                        nova_descricao = f"{descricao_original} ({data_pagamento_virtual.strftime('%m/%Y')})"
                        data_registro_nova = hoje
                        
                        if no_cartao:
                            data_pagamento_final = ajustar_para_fatura(data_pagamento_virtual, dia_fatura=config.get("dia_fatura", 10))
                        else:
                            data_pagamento_final = data_pagamento_virtual
                        
                        dados_insercao = {
                            'data_registro': data_registro_nova.isoformat(),
                            'data_pagamento': data_pagamento_final.isoformat(),
                            'pessoa': transacao_dict.get('pessoa', 'Ambos'),
                            'categoria': categoria,
                            'tipo': tipo,
                            'valor': valor,
                            'descricao': nova_descricao,
                            'recorrente': 1,
                            'dia_fixo': dia_fixo,
                            'pessoa_responsavel': transacao_dict.get('pessoa_responsavel', 'Ambos'),
                            'no_cartao': no_cartao,
                            'investimento': transacao_dict.get('investimento', 0),
                            'vr': transacao_dict.get('vr', 0),
                            'forma_pagamento': forma_pagamento,
                            'parcelas': transacao_dict.get('parcelas', 1),
                            'parcela_atual': transacao_dict.get('parcela_atual', 1),
                            'status': 'Ativa',
                            'usuario_id': usuario_id_trans,
                            'grupo': grupo_usuario,
                            'compartilhado': compartilhado_usuario
                        }
                        
                        colunas_insert = []
                        valores_insert = []
                        for col, val in dados_insercao.items():
                            if col in [c[1] for c in colunas_info]:
                                colunas_insert.append(col)
                                valores_insert.append(val)
                        
                        if colunas_insert:
                            placeholders = ', '.join(['?' for _ in colunas_insert])
                            colunas_str = ', '.join(colunas_insert)
                            
                            cur.execute(f"""
                                INSERT INTO transacoes ({colunas_str})
                                VALUES ({placeholders})
                            """, valores_insert)
                            
                            novas_transacoes += 1
            except Exception as e:
                st.error(f"Erro ao processar recorr√™ncia: {e}")
                continue
    
    conn.commit()
    conn.close()
    
    return novas_transacoes

def excluir_transacao(transacao_id, usuario_id=None):
    conn = get_conn()
    cur = conn.cursor()
    
    try:
        query = "UPDATE transacoes SET status = 'Exclu√≠da' WHERE id = ?"
        params = [transacao_id]
        
        if usuario_id:
            query += " AND usuario_id = ?"
            params.append(usuario_id)
        
        cur.execute(query, params)
        conn.commit()
        return True
    except Exception as e:
        st.error(f"Erro ao excluir transa√ß√£o: {e}")
        return False
    finally:
        conn.close()

def editar_transacao(transacao_id, novos_dados, usuario_id=None):
    conn = get_conn()
    cur = conn.cursor()
    
    try:
        date_fields = ['data_registro', 'data_pagamento']
        for field in date_fields:
            if field in novos_dados and hasattr(novos_dados[field], 'isoformat'):
                novos_dados[field] = novos_dados[field].isoformat()
        
        campos = []
        valores = []
        
        for campo, valor in novos_dados.items():
            if valor is not None and valor != '':
                campos.append(f"{campo} = ?")
                valores.append(valor)
        
        if not campos:
            return False, "Nenhum campo v√°lido para atualizar"
        
        # Adicionar condi√ß√µes
        query_condicoes = " WHERE id = ?"
        valores.append(transacao_id)
        
        if usuario_id:
            query_condicoes += " AND usuario_id = ?"
            valores.append(usuario_id)
        
        query = f"UPDATE transacoes SET {', '.join(campos)} {query_condicoes}"
        cur.execute(query, valores)
        conn.commit()
        
        cur.execute("SELECT changes()")
        changes = cur.fetchone()[0]
        
        if changes > 0:
            return True, "Transa√ß√£o atualizada com sucesso"
        else:
            return True, "Nenhuma altera√ß√£o necess√°ria"
            
    except Exception as e:
        error_msg = f"Erro ao editar transa√ß√£o: {str(e)}"
        return False, error_msg
    finally:
        conn.close()

def ler_categorias_formas():
    categorias_default = ["Alimenta√ß√£o", "Moradia", "Transporte", "Lazer", "Sa√∫de", "Educa√ß√£o", "Sal√°rio", "Outros"]
    formas_default = ["Dinheiro", "D√©bito", "Cr√©dito", "Transfer√™ncia", "Pix", "Boleto"]
    if not EXCEL_APOIO.exists():
        return categorias_default, formas_default
    try:
        df = pd.read_excel(EXCEL_APOIO, sheet_name=APOIO_SHEET)
        categorias = df.iloc[:, 0].dropna().astype(str).unique().tolist()
        formas = df.iloc[:, 1].dropna().astype(str).unique().tolist()
        return categorias, formas
    except Exception:
        return categorias_default, formas_default

def validar_transacao(data_registro, data_pagamento, descricao, valor, categoria):
    erros = []
    
    if not descricao or descricao.strip() == "":
        erros.append("Descri√ß√£o n√£o pode estar vazia")
    
    if valor <= 0:
        erros.append("Valor deve ser maior que zero")
    
    if not categoria or categoria.strip() == "":
        erros.append("Categoria √© obrigat√≥ria")
    
    return erros

# ---------- Migra√ß√£o de dados ----------
def migrar_dados_existentes():
    """Migra dados existentes para a nova estrutura"""
    conn = get_conn()
    cur = conn.cursor()
    
    try:
        # Verificar se existem transa√ß√µes sem usuario_id
        cur.execute("SELECT COUNT(*) FROM transacoes WHERE usuario_id IS NULL")
        count = cur.fetchone()[0]
        
        if count > 0:
            st.warning(f"‚ö†Ô∏è Migrando {count} transa√ß√µes existentes...")
            
            # Atribuir ao primeiro usu√°rio ADM encontrado
            cur.execute("SELECT id FROM usuarios WHERE tipo = 'ADM' ORDER BY id LIMIT 1")
            admin_id = cur.fetchone()
            
            if admin_id:
                admin_id = admin_id[0]
                cur.execute("""
                    UPDATE transacoes 
                    SET usuario_id = ?, grupo = 'padrao', compartilhado = 1
                    WHERE usuario_id IS NULL
                """, (admin_id,))
                conn.commit()
                st.success(f"‚úÖ {count} transa√ß√µes migradas para o usu√°rio admin (ID: {admin_id})")
    
    except Exception as e:
        st.error(f"Erro na migra√ß√£o: {e}")
    finally:
        conn.close()

# ---------- Interface Streamlit ----------
st.set_page_config(page_title="üí∞ Financeiro Familiar", layout="wide")

# ---------- Gerenciamento de Sess√£o ----------
if 'autenticado' not in st.session_state:
    st.session_state.autenticado = False
    st.session_state.usuario = None
    st.session_state.tipo_usuario = None
    st.session_state.usuario_id = None
    st.session_state.usuario_grupo = None
    st.session_state.usuario_compartilhado = None

if 'pagina_atual' not in st.session_state:
    st.session_state.pagina_atual = "login"

if 'form_criar_usuario_submitted' not in st.session_state:
    st.session_state.form_criar_usuario_submitted = False

# ---------- P√°gina de Login Melhorada ----------
def pagina_login():
    st.title("üîê Login - Financeiro Familiar")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        with st.container():
            st.markdown("### Acesse sua conta")
            
            # Mensagem informativa
            with st.expander("‚ÑπÔ∏è Informa√ß√µes de acesso"):
                st.info("""
                **Primeiro acesso?**
                - **Usu√°rio:** admin
                - **Senha:** admin123
                
                **‚ö†Ô∏è Importante:**
                1. Altere a senha padr√£o ap√≥s o primeiro acesso
                2. A senha deve ter pelo menos 8 caracteres
                3. Deve conter letras mai√∫sculas, min√∫sculas e n√∫meros
                """)
            
            username = st.text_input("Usu√°rio", key="login_username", 
                                    placeholder="Digite seu usu√°rio")
            senha = st.text_input("Senha", type="password", key="login_senha",
                                 placeholder="Digite sua senha")
            
            col_btn1, col_btn2, col_btn3 = st.columns(3)
            
            with col_btn1:
                if st.button("üö™ Entrar", type="primary", use_container_width=True):
                    if username and senha:
                        with st.spinner("Autenticando..."):
                            sucesso, user_data, mensagem = auth.autenticar(username, senha)
                            
                            if sucesso:
                                st.session_state.autenticado = True
                                st.session_state.usuario = user_data['username']
                                st.session_state.tipo_usuario = user_data['tipo']
                                st.session_state.usuario_id = user_data['id']
                                st.session_state.usuario_grupo = user_data['grupo']
                                st.session_state.usuario_compartilhado = user_data['compartilhado']
                                st.session_state.pagina_atual = "home"
                                st.success(mensagem)
                                st.rerun()
                            else:
                                st.error(f"‚ùå {mensagem}")
                    else:
                        st.error("‚ö†Ô∏è Preencha usu√°rio e senha")
            
            with col_btn2:
                if st.button("üîë Alterar Senha", use_container_width=True):
                    st.session_state.pagina_atual = "alterar_senha"
                    st.rerun()
            
            with col_btn3:
                if st.button("üìû Suporte", use_container_width=True):
                    st.info("""
                    **Problemas de acesso?**
                    - Verifique se o usu√°rio est√° correto
                    - Use a op√ß√£o 'Alterar Senha' se esqueceu
                    - Contate o administrador do sistema
                    """)
            
            st.markdown("---")
            
            # Credenciais padr√£o em destaque
            st.warning("""
            **Credenciais padr√£o para primeiro acesso:**
            - **Usu√°rio:** admin
            - **Senha:** admin123
            
            ‚ö†Ô∏è **ALTERE A SENHA AP√ìS O PRIMEIRO ACESSO!**
            """)

def pagina_alterar_senha():
    st.title("üîë Alterar Senha")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        with st.container():
            st.markdown("### Redefinir Senha")
            
            username = st.text_input("Usu√°rio", key="alterar_username")
            senha_atual = st.text_input("Senha Atual", type="password", key="alterar_senha_atual")
            nova_senha = st.text_input("Nova Senha", type="password", key="alterar_nova_senha")
            confirmar_senha = st.text_input("Confirmar Nova Senha", type="password", key="alterar_confirmar_senha")
            
            # Valida√ß√£o de for√ßa da senha
            if nova_senha:
                valida, msg = auth.validar_senha(nova_senha)
                if valida:
                    st.success(f"‚úÖ {msg}")
                else:
                    st.error(f"‚ùå {msg}")
            
            col_btn1, col_btn2 = st.columns(2)
            
            with col_btn1:
                if st.button("üíæ Salvar Nova Senha", type="primary", use_container_width=True):
                    if not all([username, senha_atual, nova_senha, confirmar_senha]):
                        st.error("‚ö†Ô∏è Preencha todos os campos")
                    elif nova_senha != confirmar_senha:
                        st.error("‚ö†Ô∏è As senhas n√£o coincidem")
                    else:
                        # Validar for√ßa da senha
                        valida, msg = auth.validar_senha(nova_senha)
                        if not valida:
                            st.error(f"‚ùå {msg}")
                        else:
                            sucesso, mensagem = auth.alterar_senha(username, senha_atual, nova_senha)
                            if sucesso:
                                st.success(f"‚úÖ {mensagem}")
                                st.info("üîë Senha alterada com sucesso! Use a nova senha para fazer login.")
                                st.session_state.pagina_atual = "login"
                                st.rerun()
                            else:
                                st.error(f"‚ùå {mensagem}")
            
            with col_btn2:
                if st.button("‚Ü©Ô∏è Voltar para Login", use_container_width=True):
                    st.session_state.pagina_atual = "login"
                    st.rerun()

def pagina_recuperar_senha():
    st.title("üîë Recupera√ß√£o de Senha")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        with st.container():
            st.markdown("### Redefinir Senha")
            
            username = st.text_input("Usu√°rio", key="recuperar_username")
            senha_atual = st.text_input("Senha Atual", type="password", key="recuperar_senha_atual")
            nova_senha = st.text_input("Nova Senha", type="password", key="recuperar_nova_senha")
            confirmar_senha = st.text_input("Confirmar Nova Senha", type="password", key="recuperar_confirmar_senha")
            
            if st.button("Alterar Senha", type="primary", use_container_width=True):
                if not all([username, senha_atual, nova_senha, confirmar_senha]):
                    st.error("Preencha todos os campos")
                elif nova_senha != confirmar_senha:
                    st.error("As senhas n√£o coincidem")
                else:
                    sucesso, mensagem = auth.alterar_senha(username, senha_atual, nova_senha)
                    if sucesso:
                        st.success(mensagem)
                        st.session_state.pagina_atual = "login"
                        st.rerun()
                    else:
                        st.error(mensagem)
            
            if st.button("Voltar para Login", use_container_width=True):
                st.session_state.pagina_atual = "login"
                st.rerun()

# ---------- P√°gina Principal ----------
def pagina_principal():
    # Barra lateral com informa√ß√µes do usu√°rio
    with st.sidebar:
        st.markdown(f"### üë§ {st.session_state.usuario}")
        st.markdown(f"**Tipo:** {st.session_state.tipo_usuario}")
        st.markdown(f"**Grupo:** {st.session_state.usuario_grupo}")
        st.markdown(f"**Base:** {'Compartilhada' if st.session_state.usuario_compartilhado == 1 else 'Separada'}")
        
        if st.button("üö™ Sair", use_container_width=True):
            st.session_state.autenticado = False
            st.session_state.usuario = None
            st.session_state.tipo_usuario = None
            st.session_state.usuario_id = None
            st.session_state.pagina_atual = "login"
            st.rerun()
        
        st.markdown("---")
        
        # Menu baseado no tipo de usu√°rio
        if st.session_state.tipo_usuario == "ADM":
            menu_opcoes = ["üìä Dashboard", "‚ûï Novo Registro", "üìã Consultar Finan√ßas", 
                          "üõ†Ô∏è Gerenciar Transa√ß√µes", "üë• Gerenciar Usu√°rios", "‚öôÔ∏è Configura√ß√µes"]
        else:
            menu_opcoes = ["üìä Dashboard", "‚ûï Novo Registro", "üìã Consultar Finan√ßas", 
                          "üõ†Ô∏è Gerenciar Transa√ß√µes", "üîß Minha Conta"]
        
        menu = st.radio("Menu", menu_opcoes)
        
        # Processar recorr√™ncias autom√°ticas
        try:
            novas_transacoes = processar_recorrencias_automaticas(st.session_state.usuario_id)
            if novas_transacoes > 0:
                st.success(f"üîÑ {novas_transacoes} transa√ß√µes recorrentes criadas!")
        except Exception as e:
            st.error(f"‚ö†Ô∏è Erro ao processar recorr√™ncias: {e}")
            st.error(traceback.format_exc())
    
    # Conte√∫do principal baseado na sele√ß√£o do menu
    if menu == "üìä Dashboard":
        pagina_dashboard()
    elif menu == "‚ûï Novo Registro":
        pagina_novo_registro()
    elif menu == "üìã Consultar Finan√ßas":
        pagina_consultar_financas()
    elif menu == "üõ†Ô∏è Gerenciar Transa√ß√µes":
        pagina_gerenciar_transacoes()
    elif menu == "üë• Gerenciar Usu√°rios" and st.session_state.tipo_usuario == "ADM":
        pagina_gerenciar_usuarios()
    elif menu == "üîß Minha Conta":
        pagina_minha_conta()
    elif menu == "‚öôÔ∏è Configura√ß√µes" and st.session_state.tipo_usuario == "ADM":
        pagina_configuracoes()

# ---------- P√°ginas Espec√≠ficas ----------
def pagina_dashboard():
    st.title("üìä Dashboard Financeiro")
    
    df = carregar_transacoes(st.session_state.usuario_id)
    
    if df.empty:
        st.info("üìù Nenhuma transa√ß√£o cadastrada ainda.")
        return
    
    # M√©tricas do m√™s atual
    hoje = datetime.now()
    mes_atual = hoje.month
    ano_atual = hoje.year
    
    df_mes = df.copy()
    if 'data_pagamento' in df_mes.columns and pd.api.types.is_datetime64_any_dtype(df_mes['data_pagamento']):
        df_mes = df_mes[
            (df_mes['data_pagamento'].dt.month == mes_atual) &
            (df_mes['data_pagamento'].dt.year == ano_atual)
        ]
    
    if not df_mes.empty:
        total_receitas = df_mes[df_mes['tipo'] == 'Receita']['valor'].sum()
        total_despesas = df_mes[df_mes['tipo'] == 'Despesa']['valor'].sum()
        saldo_mes = total_receitas - total_despesas
        
        col1, col2, col3 = st.columns(3)
        col1.metric("üí∞ Receitas do M√™s", f"R$ {total_receitas:,.2f}")
        col2.metric("üí∏ Despesas do M√™s", f"R$ {total_despesas:,.2f}")
        
        cor_saldo = "normal" if saldo_mes >= 0 else "inverse"
        col3.metric("üìä Saldo do M√™s", f"R$ {saldo_mes:,.2f}", delta_color=cor_saldo)
        
        # Gr√°fico de despesas por categoria
        st.subheader("üìà Distribui√ß√£o de Despesas por Categoria")
        
        df_despesas = df_mes[df_mes['tipo'] == 'Despesa']
        if not df_despesas.empty:
            despesas_categoria = df_despesas.groupby('categoria')['valor'].sum().reset_index()
            if len(despesas_categoria) > 0:
                fig = px.pie(despesas_categoria, names='categoria', values='valor',
                            title='Despesas por Categoria')
                st.plotly_chart(fig, use_container_width=True)
        
        # √öltimas transa√ß√µes
        st.subheader("üîÑ √öltimas Transa√ß√µes")
        df_ultimas = df.head(10).copy()
        
        if 'data_pagamento' in df_ultimas.columns and pd.api.types.is_datetime64_any_dtype(df_ultimas['data_pagamento']):
            df_ultimas['data_pagamento'] = df_ultimas['data_pagamento'].dt.strftime('%d/%m/%Y')
        
        if 'data_registro' in df_ultimas.columns and pd.api.types.is_datetime64_any_dtype(df_ultimas['data_registro']):
            df_ultimas['data_registro'] = df_ultimas['data_registro'].dt.strftime('%d/%m/%Y')
        
        colunas_mostrar = []
        for col in ['data_pagamento', 'data_registro', 'descricao', 'categoria', 'tipo', 'valor', 'usuario_nome']:
            if col in df_ultimas.columns:
                colunas_mostrar.append(col)
        
        if colunas_mostrar:
            st.dataframe(df_ultimas[colunas_mostrar], use_container_width=True)
    else:
        st.info("üìÖ Nenhuma transa√ß√£o registrada para este m√™s.")

def pagina_novo_registro():
    st.header("‚ûï Novo Registro")
    
    if 'success_message' not in st.session_state:
        st.session_state.success_message = None
    
    if st.session_state.success_message:
        st.success(st.session_state.success_message)
        st.session_state.success_message = None
    
    col1, col2 = st.columns(2)
    
    with col1:
        tipo = st.radio("Tipo", ["Receita", "Despesa"], index=1, horizontal=True, key="novo_tipo")
        descricao = st.text_input("Descri√ß√£o", value="", key="novo_descricao")
        valor = st.number_input("Valor (R$)", min_value=0.01, value=0.01, format="%.2f", step=0.01, key="novo_valor")
        categorias, formas = ler_categorias_formas()
        categoria = st.selectbox("Categoria", categorias, key="novo_categoria")
    
    with col2:
        forma = st.selectbox("Forma de pagamento", formas, key="novo_forma")
        no_cartao = forma.lower() in ["cr√©dito", "credito", "cart√£o", "cartao"]
        
        st.markdown("**Data do Registro**")
        st.info("Data em que voc√™ est√° registrando esta transa√ß√£o no sistema")
        data_registro = st.date_input("", value=date.today(), key="data_registro_novo", label_visibility="collapsed")
        
        st.markdown("**Data do Pagamento**")
        
        if no_cartao:
            st.info("Data em que a compra foi realizada no cart√£o")
            data_compra = st.date_input("", value=date.today(), key="data_compra_novo", label_visibility="collapsed")
            data_pagamento = ajustar_para_fatura(data_compra, dia_fatura=config.get("dia_fatura", 10))
            st.success(f"**Fatura:** {data_pagamento.strftime('%d/%m/%Y')}")
        else:
            st.info("Data em que o pagamento foi/ser√° realizado")
            data_pagamento = st.date_input("", value=date.today(), key="data_pagamento_novo", label_visibility="collapsed")
    
    st.markdown("---")
    st.subheader("üîÅ Op√ß√µes de Pagamento")
    
    opcao_pagamento = st.radio("Selecione o tipo:", 
                              ["√Ä Vista", "Parcelado", "Recorrente"],
                              horizontal=True,
                              index=0,
                              key="novo_opcao")
    
    parcelas = 1
    dia_fixo = None
    
    if opcao_pagamento == "Parcelado":
        parcelas = st.number_input("N√∫mero de parcelas", min_value=2, max_value=24, value=2, key="novo_parcelas")
        valor_parcela = valor / parcelas
        st.info(f"üí∏ **Valor por parcela:** R$ {valor_parcela:,.2f}")
    
    elif opcao_pagamento == "Recorrente":
        st.info("üîÑ **Recorrente:** Ser√° cobrada automaticamente todo m√™s")
        if no_cartao:
            dia_fixo = data_compra.day
        else:
            dia_fixo = data_pagamento.day
        st.info(f"üìÖ **Dia fixo:** {dia_fixo}¬∫ dia do m√™s")
    
    if st.button("üíæ Salvar Registro", type="primary", key="novo_salvar"):
        erros = validar_transacao(data_registro, data_pagamento, descricao, valor, categoria)
        if erros:
            for erro in erros:
                st.error(f"‚ùå {erro}")
        else:
            try:
                mensagem = ""
                
                if opcao_pagamento == "Parcelado":
                    # Parcelado: criar m√∫ltiplos registros
                    valor_parcela = valor / parcelas
                    
                    for i in range(parcelas):
                        # Calcular data de cada parcela
                        if no_cartao:
                            # Para cr√©dito: cada parcela tem sua pr√≥pria data de compra
                            ano_compra = data_compra.year + (data_compra.month + i - 1) // 12
                            mes_compra = (data_compra.month + i - 1) % 12 + 1
                            dia_compra = min(data_compra.day, calendar.monthrange(ano_compra, mes_compra)[1])
                            data_compra_parcela = date(ano_compra, mes_compra, dia_compra)
                            data_pagamento_parcela = ajustar_para_fatura(data_compra_parcela, dia_fatura=config.get("dia_fatura", 10))
                        else:
                            # Para outras formas: parcelas no mesmo dia do m√™s
                            ano_pag = data_pagamento.year + (data_pagamento.month + i - 1) // 12
                            mes_pag = (data_pagamento.month + i - 1) % 12 + 1
                            dia_pag = min(data_pagamento.day, calendar.monthrange(ano_pag, mes_pag)[1])
                            data_pagamento_parcela = date(ano_pag, mes_pag, dia_pag)
                        
                        desc_parcela = f"{descricao} ({i+1}/{parcelas})"
                        
                        extra_fields = {
                            "no_cartao": 1 if no_cartao else 0,
                            "parcelas": parcelas,
                            "parcela_atual": i + 1
                        }
                        
                        inserir_transacao(tipo, data_registro, data_pagamento_parcela, 
                                        desc_parcela, valor_parcela, categoria, forma, 
                                        extra_fields, st.session_state.usuario_id)
                    
                    mensagem = f"‚úÖ {parcelas} parcelas de R$ {valor_parcela:,.2f} registradas com sucesso!"
                
                elif opcao_pagamento == "Recorrente":
                    # Recorrente: criar 1 registro com flag de recorr√™ncia
                    extra_fields = {
                        "recorrente": 1,
                        "dia_fixo": dia_fixo,
                        "no_cartao": 1 if no_cartao else 0
                    }
                    
                    inserir_transacao(tipo, data_registro, data_pagamento, 
                                    descricao, valor, categoria, forma, 
                                    extra_fields, st.session_state.usuario_id)
                    mensagem = "‚úÖ Transa√ß√£o recorrente registrada com sucesso!"
                    st.info("üîÑ As recorr√™ncias futuras ser√£o criadas automaticamente!")
                
                else:
                    # √Ä vista: criar 1 registro normal
                    extra_fields = {
                        "no_cartao": 1 if no_cartao else 0
                    }
                    
                    inserir_transacao(tipo, data_registro, data_pagamento, 
                                    descricao, valor, categoria, forma, 
                                    extra_fields, st.session_state.usuario_id)
                    mensagem = f"‚úÖ {tipo} registrada com sucesso!"
                
                # Armazenar mensagem de sucesso
                st.session_state.success_message = mensagem
                st.rerun()
                    
            except Exception as e:
                st.error(f"‚ùå Erro ao salvar: {str(e)}")
                st.error(traceback.format_exc())

def pagina_consultar_financas():
    st.header("üìä Consultar Finan√ßas")
    
    df = carregar_transacoes(st.session_state.usuario_id)
    
    if df.empty:
        st.info("üìù Nenhuma transa√ß√£o cadastrada ainda.")
        return
    
    # Filtros
    st.subheader("üìÖ Filtros")
    filtro_tipo = st.radio(
        "Filtrar por:",
        ["Data de Pagamento", "Data de Registro"],
        horizontal=True,
        key="filtro_tipo_consulta"
    )
    
    coluna_filtro = 'data_pagamento' if filtro_tipo == "Data de Pagamento" else 'data_registro'
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        meses = ["Todos"] + [f"{m:02d}" for m in range(1, 13)]
        hoje = datetime.now()
        mes_sel = st.selectbox("M√™s", meses, index=hoje.month, key="mes_filtro")
    
    with col2:
        if pd.api.types.is_datetime64_any_dtype(df[coluna_filtro]):
            anos = sorted(df[coluna_filtro].dt.year.dropna().unique(), reverse=True)
        else:
            anos = [hoje.year]
        
        anos_lista = ["Todos"] + [str(int(ano)) for ano in anos]
        ano_sel = st.selectbox("Ano", anos_lista, index=0, key="ano_filtro")
    
    with col3:
        tipo_sel = st.selectbox("Tipo", ["Todos", "Receita", "Despesa"], key="tipo_filtro")
    
    with col4:
        _, formas = ler_categorias_formas()
        forma_sel = st.selectbox("Forma", ["Todas"] + formas, key="forma_filtro")
    
    # Aplicar filtros
    df_filtrado = df.copy()
    
    if mes_sel != "Todos" and pd.api.types.is_datetime64_any_dtype(df_filtrado[coluna_filtro]):
        df_filtrado = df_filtrado[df_filtrado[coluna_filtro].dt.month == int(mes_sel)]
    
    if ano_sel != "Todos" and pd.api.types.is_datetime64_any_dtype(df_filtrado[coluna_filtro]):
        df_filtrado = df_filtrado[df_filtrado[coluna_filtro].dt.year == int(ano_sel)]
    
    if tipo_sel != "Todos":
        df_filtrado = df_filtrado[df_filtrado['tipo'] == tipo_sel]
    
    if forma_sel != "Todas":
        df_filtrado = df_filtrado[df_filtrado['forma_pagamento'] == forma_sel]
    
    if df_filtrado.empty:
        st.warning("üîç Nenhum registro encontrado com os filtros selecionados.")
    else:
        # M√©tricas
        total_receitas = df_filtrado[df_filtrado['tipo'] == 'Receita']['valor'].sum()
        total_despesas = df_filtrado[df_filtrado['tipo'] == 'Despesa']['valor'].sum()
        saldo = total_receitas - total_despesas
        
        col_metrica1, col_metrica2, col_metrica3 = st.columns(3)
        col_metrica1.metric("üí∞ Receitas", f"R$ {total_receitas:,.2f}")
        col_metrica2.metric("üí∏ Despesas", f"R$ {total_despesas:,.2f}")
        
        cor_saldo = "normal" if saldo >= 0 else "inverse"
        col_metrica3.metric("üìä Saldo", f"R$ {saldo:,.2f}", delta_color=cor_saldo)
        
        # Gr√°ficos
        if not df_filtrado.empty:
            col_graf1, col_graf2 = st.columns(2)
            
            with col_graf1:
                graf_categoria = df_filtrado.groupby("categoria")['valor'].sum().reset_index()
                if not graf_categoria.empty and len(graf_categoria) > 0:
                    fig = px.pie(graf_categoria, names='categoria', values='valor', 
                                title='üìà Distribui√ß√£o por Categoria')
                    st.plotly_chart(fig, use_container_width=True)
            
            with col_graf2:
                graf_forma = df_filtrado.groupby("forma_pagamento")['valor'].sum().reset_index()
                if not graf_forma.empty and len(graf_forma) > 0:
                    fig2 = px.pie(graf_forma, names='forma_pagamento', values='valor',
                                 title='üí≥ Distribui√ß√£o por Forma de Pagamento')
                    st.plotly_chart(fig2, use_container_width=True)
        
        # Tabela
        st.subheader("üìã Registros Detalhados")
        
        df_display = df_filtrado.copy()
        
        date_columns = ['data_registro', 'data_pagamento']
        for col in date_columns:
            if col in df_display.columns and pd.api.types.is_datetime64_any_dtype(df_display[col]):
                df_display[col] = df_display[col].apply(
                    lambda x: x.strftime('%d/%m/%Y') if pd.notna(x) else ''
                )
        
        df_display['valor'] = df_display['valor'].apply(lambda x: f"R$ {x:,.2f}")
        
        colunas = ['id', 'data_registro', 'data_pagamento', 'categoria', 
                  'tipo', 'forma_pagamento', 'valor', 'descricao', 'usuario_nome']
        
        colunas_existentes = [col for col in colunas if col in df_display.columns]
        st.dataframe(df_display[colunas_existentes], use_container_width=True, height=400)

def pagina_gerenciar_transacoes():
    st.header("üõ†Ô∏è Gerenciar Transa√ß√µes")
    
    if 'editando_id' not in st.session_state:
        st.session_state.editando_id = None
        st.session_state.editando_dados = {}
    
    df = carregar_transacoes(st.session_state.usuario_id)
    
    if 'status' in df.columns:
        df_ativas = df[df['status'] != 'Exclu√≠da']
    else:
        df_ativas = df
    
    if df_ativas.empty:
        st.info("üìù Nenhuma transa√ß√£o cadastrada ainda.")
    else:
        col1, col2 = st.columns(2)
        with col1:
            busca_descricao = st.text_input("üîç Buscar por descri√ß√£o", key="busca_descricao")
        with col2:
            categorias, _ = ler_categorias_formas()
            categoria_filtro = st.selectbox("Filtrar por categoria", ["Todas"] + categorias, key="filtro_categoria")
        
        df_filtrado = df_ativas.copy()
        if busca_descricao:
            df_filtrado = df_filtrado[df_filtrado['descricao'].str.contains(busca_descricao, case=False, na=False)]
        if categoria_filtro != "Todas":
            df_filtrado = df_filtrado[df_filtrado['categoria'] == categoria_filtro]
        
        if df_filtrado.empty:
            st.warning("üîç Nenhuma transa√ß√£o encontrada com os filtros selecionados.")
        else:
            st.subheader(f"üìã Transa√ß√µes Encontradas ({len(df_filtrado)})")
            
            if st.session_state.editando_id is not None:
                transacao_editar = df_filtrado[df_filtrado['id'] == st.session_state.editando_id]
                
                if not transacao_editar.empty:
                    transacao = transacao_editar.iloc[0]
                    st.subheader(f"‚úèÔ∏è Editando: {transacao['descricao']}")
                    
                    if not st.session_state.editando_dados:
                        date_fields = ['data_registro', 'data_pagamento']
                        for field in date_fields:
                            if field in transacao:
                                valor_campo = transacao[field]
                                if isinstance(valor_campo, pd.Timestamp):
                                    st.session_state.editando_dados[field] = valor_campo.date()
                                elif isinstance(valor_campo, datetime):
                                    st.session_state.editando_dados[field] = valor_campo.date()
                                elif isinstance(valor_campo, date):
                                    st.session_state.editando_dados[field] = valor_campo
                                elif isinstance(valor_campo, str):
                                    try:
                                        st.session_state.editando_dados[field] = datetime.strptime(valor_campo, '%Y-%m-%d').date()
                                    except:
                                        st.session_state.editando_dados[field] = date.today()
                                else:
                                    st.session_state.editando_dados[field] = date.today()
                            else:
                                st.session_state.editando_dados[field] = date.today()
                        
                        st.session_state.editando_dados.update({
                            'descricao': transacao['descricao'],
                            'valor': float(transacao['valor']),
                            'categoria': transacao['categoria'],
                            'forma_pagamento': transacao['forma_pagamento'],
                            'tipo': transacao['tipo'],
                            'no_cartao': transacao.get('no_cartao', 0)
                        })
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        nova_descricao = st.text_input(
                            "Descri√ß√£o", 
                            value=st.session_state.editando_dados['descricao'],
                            key=f"edit_desc_{transacao['id']}"
                        )
                        
                        novo_valor = st.number_input(
                            "Valor (R$)", 
                            value=st.session_state.editando_dados['valor'],
                            min_value=0.01, 
                            format="%.2f",
                            key=f"edit_valor_{transacao['id']}"
                        )
                        
                        categorias, formas = ler_categorias_formas()
                        cat_index = 0
                        if st.session_state.editando_dados['categoria'] in categorias:
                            cat_index = categorias.index(st.session_state.editando_dados['categoria'])
                        nova_categoria = st.selectbox(
                            "Categoria", 
                            categorias, 
                            index=cat_index,
                            key=f"edit_cat_{transacao['id']}"
                        )
                    
                    with col2:
                        nova_data_registro = st.date_input(
                            "Data de Registro", 
                            value=st.session_state.editando_dados.get('data_registro', date.today()),
                            key=f"edit_data_reg_{transacao['id']}"
                        )
                        
                        nova_data_pagamento = st.date_input(
                            "Data de Pagamento", 
                            value=st.session_state.editando_dados.get('data_pagamento', date.today()),
                            key=f"edit_data_pag_{transacao['id']}"
                        )
                        
                        forma_index = 0
                        if st.session_state.editando_dados['forma_pagamento'] in formas:
                            forma_index = formas.index(st.session_state.editando_dados['forma_pagamento'])
                        nova_forma = st.selectbox(
                            "Forma de Pagamento", 
                            formas, 
                            index=forma_index,
                            key=f"edit_forma_{transacao['id']}"
                        )
                        
                        tipo_index = 0 if st.session_state.editando_dados['tipo'] == "Receita" else 1
                        novo_tipo = st.radio(
                            "Tipo", 
                            ["Receita", "Despesa"], 
                            index=tipo_index,
                            horizontal=True,
                            key=f"edit_tipo_{transacao['id']}"
                        )
                    
                    col_salvar, col_cancelar, col_espaco = st.columns([1, 1, 2])
                    
                    with col_salvar:
                        if st.button("üíæ Salvar Altera√ß√µes", key=f"save_{transacao['id']}"):
                            erros = []
                            if not nova_descricao or nova_descricao.strip() == "":
                                erros.append("Descri√ß√£o n√£o pode estar vazia")
                            if novo_valor <= 0:
                                erros.append("Valor deve ser maior que zero")
                            
                            if erros:
                                for erro in erros:
                                    st.error(f"‚ùå {erro}")
                            else:
                                dados_atualizados = {
                                    'descricao': str(nova_descricao),
                                    'valor': float(novo_valor),
                                    'categoria': str(nova_categoria),
                                    'data_registro': nova_data_registro,
                                    'data_pagamento': nova_data_pagamento,
                                    'forma_pagamento': str(nova_forma),
                                    'tipo': str(novo_tipo)
                                }
                                
                                sucesso, mensagem = editar_transacao(
                                    transacao['id'], 
                                    dados_atualizados, 
                                    st.session_state.usuario_id
                                )
                                if sucesso:
                                    st.success(f"‚úÖ {mensagem}")
                                    st.session_state.editando_id = None
                                    st.session_state.editando_dados = {}
                                    st.rerun()
                                else:
                                    st.error(f"‚ùå {mensagem}")
                    
                    with col_cancelar:
                        if st.button("‚ùå Cancelar", key=f"cancel_{transacao['id']}"):
                            st.session_state.editando_id = None
                            st.session_state.editando_dados = {}
                            st.rerun()
                    
                    if st.button("‚¨ÖÔ∏è Voltar para a lista", key=f"back_{transacao['id']}"):
                        st.session_state.editando_id = None
                        st.session_state.editando_dados = {}
                        st.rerun()
            
            else:
                for idx, transacao in df_filtrado.iterrows():
                    data_registro = transacao.get('data_registro')
                    data_pagamento = transacao.get('data_pagamento')
                    
                    data_registro_str = ''
                    data_pagamento_str = ''
                    
                    if isinstance(data_registro, (date, datetime, pd.Timestamp)):
                        if pd.notna(data_registro):
                            if isinstance(data_registro, pd.Timestamp):
                                data_registro_str = data_registro.strftime('%d/%m/%Y')
                            elif isinstance(data_registro, (date, datetime)):
                                data_registro_str = data_registro.strftime('%d/%m/%Y')
                    elif data_registro is not None:
                        data_registro_str = str(data_registro)
                    
                    if isinstance(data_pagamento, (date, datetime, pd.Timestamp)):
                        if pd.notna(data_pagamento):
                            if isinstance(data_pagamento, pd.Timestamp):
                                data_pagamento_str = data_pagamento.strftime('%d/%m/%Y')
                            elif isinstance(data_pagamento, (date, datetime)):
                                data_pagamento_str = data_pagamento.strftime('%d/%m/%Y')
                    elif data_pagamento is not None:
                        data_pagamento_str = str(data_pagamento)
                    
                    is_credito = transacao.get('no_cartao', 0) == 1 or 'cr√©dito' in str(transacao.get('forma_pagamento', '')).lower()
                    
                    with st.expander(f"{transacao['descricao']} - R$ {transacao['valor']:,.2f} (Pagamento: {data_pagamento_str})"):
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            st.write(f"**ID:** {transacao['id']}")
                            st.write(f"**Registro:** {data_registro_str}")
                            st.write(f"**Pagamento:** {data_pagamento_str}")
                            if is_credito:
                                st.write("üí≥ **Cart√£o de Cr√©dito**")
                            st.write(f"**Categoria:** {transacao['categoria']}")
                            st.write(f"**Tipo:** {transacao['tipo']}")
                            st.write(f"**Forma:** {transacao['forma_pagamento']}")
                            if transacao.get('parcelas', 1) > 1:
                                st.write(f"**Parcela:** {transacao.get('parcela_atual', 1)}/{transacao.get('parcelas', 1)}")
                            if transacao.get('recorrente', 0) == 1:
                                st.write("üîÑ **Recorrente**")
                            if 'usuario_nome' in transacao:
                                st.write(f"**Usu√°rio:** {transacao['usuario_nome']}")
                        
                        with col2:
                            if st.button("‚úèÔ∏è Editar", key=f"edit_btn_{transacao['id']}"):
                                st.session_state.editando_id = transacao['id']
                                st.session_state.editando_dados = {}
                                st.rerun()
                        
                        with col3:
                            if st.button("üóëÔ∏è Excluir", key=f"del_btn_{transacao['id']}"):
                                if excluir_transacao(transacao['id'], st.session_state.usuario_id):
                                    st.success("‚úÖ Transa√ß√£o marcada como exclu√≠da!")
                                    st.rerun()

def pagina_gerenciar_usuarios():
    st.header("üë• Gerenciar Usu√°rios")
    
    if st.session_state.tipo_usuario != "ADM":
        st.error("‚ùå Acesso restrito a administradores.")
        return
    
    tab1, tab2 = st.tabs(["üìã Lista de Usu√°rios", "‚ûï Criar Novo Usu√°rio"])
    
    with tab1:
        usuarios, colunas = auth.listar_usuarios()
        
        if not usuarios:
            st.info("üìù Nenhum usu√°rio cadastrado.")
        else:
            st.subheader("üìä Usu√°rios do Sistema")
            
            for usuario in usuarios:
                usuario_dict = dict(zip(colunas, usuario))
                
                with st.expander(f"{usuario_dict['username']} ({usuario_dict['tipo']})"):
                    col1, col2, col3 = st.columns([2, 1, 1])
                    
                    with col1:
                        st.write(f"**ID:** {usuario_dict['id']}")
                        st.write(f"**Nome:** {usuario_dict['nome'] or 'N√£o informado'}")
                        st.write(f"**Email:** {usuario_dict['email'] or 'N√£o informado'}")
                        st.write(f"**Tipo:** {usuario_dict['tipo']}")
                        st.write(f"**Grupo:** {usuario_dict['grupo'] or 'padrao'}")
                        st.write(f"**Base:** {'Compartilhada' if usuario_dict['compartilhado'] == 1 else 'Separada'}")
                        st.write(f"**Status:** {'‚úÖ Ativo' if usuario_dict['ativo'] else '‚ùå Inativo'}")
                        st.write(f"**Criado em:** {usuario_dict['data_criacao']}")
                        st.write(f"**√öltimo login:** {usuario_dict['data_ultimo_login'] or 'Nunca'}")
                    
                    with col2:
                        if usuario_dict['username'] != st.session_state.usuario:
                            col_status, col_tipo = st.columns(2)
                            
                            with col_status:
                                novo_status = st.checkbox(
                                    "Ativo", 
                                    value=bool(usuario_dict['ativo']),
                                    key=f"status_{usuario_dict['id']}"
                                )
                                if novo_status != bool(usuario_dict['ativo']):
                                    sucesso, msg = auth.alterar_status_usuario(usuario_dict['id'], novo_status)
                                    if sucesso:
                                        st.success(msg)
                                        st.rerun()
                                    else:
                                        st.error(msg)
                            
                            with col_tipo:
                                novotipo = st.selectbox(
                                    "Tipo",
                                    ["COMUM", "ADM"],
                                    index=0 if usuario_dict['tipo'] == "COMUM" else 1,
                                    key=f"tipo_{usuario_dict['id']}"
                                )
                                if novotipo != usuario_dict['tipo']:
                                    sucesso, msg = auth.alterar_tipo_usuario(usuario_dict['id'], novotipo)
                                    if sucesso:
                                        st.success(msg)
                                        st.rerun()
                                    else:
                                        st.error(msg)
                    
                    with col3:
                        if usuario_dict['username'] != st.session_state.usuario:
                            st.subheader("Grupo/Base")
                            novo_grupo = st.text_input(
                                "Grupo",
                                value=usuario_dict['grupo'] or 'padrao',
                                key=f"grupo_{usuario_dict['id']}"
                            )
                            
                            novo_compartilhado = st.selectbox(
                                "Base de dados",
                                ["Separada", "Compartilhada"],
                                index=0 if usuario_dict['compartilhado'] == 0 else 1,
                                key=f"compart_{usuario_dict['id']}"
                            )
                            
                            if st.button("Atualizar Grupo", key=f"upd_grupo_{usuario_dict['id']}"):
                                compartilhado_int = 1 if novo_compartilhado == "Compartilhada" else 0
                                sucesso, msg = auth.alterar_grupo_usuario(
                                    usuario_dict['id'], novo_grupo, compartilhado_int
                                )
                                if sucesso:
                                    st.success(msg)
                                    st.rerun()
                                else:
                                    st.error(msg)
                        
                        st.write("")  # Espa√ßo
    
    with tab2:
        st.subheader("‚ûï Criar Novo Usu√°rio")
        
        # Resetar estado se necess√°rio
        if st.button("üîÑ Limpar formul√°rio"):
            st.session_state.form_criar_usuario_submitted = False
            st.rerun()
        
        with st.form("form_criar_usuario", clear_on_submit=True):
            col1, col2 = st.columns(2)
            
            with col1:
                username = st.text_input("Nome de usu√°rio *")
                senha = st.text_input("Senha *", type="password")
                confirmar_senha = st.text_input("Confirmar senha *", type="password")
            
            with col2:
                nome = st.text_input("Nome completo")
                email = st.text_input("Email")
                tipo = st.selectbox("Tipo de usu√°rio", ["COMUM", "ADM"])
                grupo = st.text_input("Grupo", value="padrao", 
                                    help="Usu√°rios no mesmo grupo compartilham dados")
                compartilhado = st.selectbox(
                    "Base de dados", 
                    ["Compartilhada (v√™ dados do grupo)", "Separada (s√≥ v√™ seus dados)"],
                    index=0
                )
            
            submitted = st.form_submit_button("Criar Usu√°rio", type="primary")
            
            if submitted:
                if not all([username, senha, confirmar_senha]):
                    st.error("Preencha todos os campos obrigat√≥rios (*)")
                elif senha != confirmar_senha:
                    st.error("As senhas n√£o coincidem")
                else:
                    # Converter op√ß√£o de compartilhamento
                    compartilhado_int = 1 if compartilhado.startswith("Compartilhada") else 0
                    
                    sucesso, mensagem, usuario_id = auth.criar_usuario(
                        username, senha, tipo, nome, email, grupo, compartilhado_int
                    )
                    if sucesso:
                        st.success(f"‚úÖ {mensagem} - ID: {usuario_id}")
                        st.session_state.form_criar_usuario_submitted = True
                        # N√£o usar st.rerun() aqui para manter a mensagem vis√≠vel
                    else:
                        st.error(f"‚ùå {mensagem}")
        
        # Se o formul√°rio foi enviado com sucesso, mostrar mensagem e op√ß√£o para criar outro
        if st.session_state.form_criar_usuario_submitted:
            st.info("Usu√°rio criado com sucesso! O formul√°rio foi limpo.")
            if st.button("‚ûï Criar outro usu√°rio"):
                st.session_state.form_criar_usuario_submitted = False
                st.rerun()

def pagina_minha_conta():
    st.header("üîß Minha Conta")
    
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.info(f"""
        **Informa√ß√µes da conta:**
        - **Usu√°rio:** {st.session_state.usuario}
        - **Tipo:** {st.session_state.tipo_usuario}
        - **ID:** {st.session_state.usuario_id}
        - **Grupo:** {st.session_state.usuario_grupo}
        - **Base:** {'Compartilhada' if st.session_state.usuario_compartilhado == 1 else 'Separada'}
        """)
    
    with col2:
        st.subheader("üîê Alterar Senha")
        
        with st.form("form_alterar_senha"):
            senha_atual = st.text_input("Senha atual", type="password")
            nova_senha = st.text_input("Nova senha", type="password")
            confirmar_senha = st.text_input("Confirmar nova senha", type="password")
            
            if st.form_submit_button("Alterar Senha", type="primary"):
                if not all([senha_atual, nova_senha, confirmar_senha]):
                    st.error("Preencha todos os campos")
                elif nova_senha != confirmar_senha:
                    st.error("As novas senhas n√£o coincidem")
                else:
                    sucesso, mensagem = auth.alterar_senha(st.session_state.usuario, senha_atual, nova_senha)
                    if sucesso:
                        st.success(mensagem)
                    else:
                        st.error(mensagem)

def pagina_configuracoes():
    st.header("‚öôÔ∏è Configura√ß√µes do Sistema")
    
    if st.session_state.tipo_usuario != "ADM":
        st.error("‚ùå Acesso restrito a administradores.")
        return
    
    tab1, tab2 = st.tabs(["üîÑ Configura√ß√µes Gerais", "üìä Estat√≠sticas"])
    
    with tab1:
        st.subheader("Configura√ß√µes da Fatura")
        
        dia_fatura = st.number_input("Dia de vencimento da fatura (1-31)", 
                                    min_value=1, max_value=31, 
                                    value=int(config.get("dia_fatura", 10)),
                                    help="Dia que a fatura vence (normalmente dia 10)")
        
        if st.button("Salvar configura√ß√£o", type="primary"):
            config["dia_fatura"] = int(dia_fatura)
            save_config(config)
            st.success(f"‚úÖ Configura√ß√£o salva: Fatura dia {dia_fatura}")
        
        st.info(f"""
        **üìã REGRA DO CART√ÉO DE CR√âDITO:**
        - **Compras em qualquer dia do m√™s ‚Üí Fatura no dia {dia_fatura:02d} do PR√ìXIMO m√™s**
        
        **Exemplos:**
        - Compra em 15/11 ‚Üí Fatura em {dia_fatura:02d}/12
        - Compra em 20/12 ‚Üí Fatura em {dia_fatura:02d}/01
        """)
    
    with tab2:
        st.subheader("üìä Estat√≠sticas do Sistema")
        
        conn = sqlite3.connect(DB_FILE)
        cur = conn.cursor()
        
        # Contar usu√°rios
        cur.execute("SELECT COUNT(*) FROM usuarios")
        total_usuarios = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM usuarios WHERE tipo = 'ADM'")
        admins = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM usuarios WHERE tipo = 'COMUM'")
        comuns = cur.fetchone()[0]
        
        # Contar transa√ß√µes
        cur.execute("SELECT COUNT(*) FROM transacoes")
        total_transacoes = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM transacoes WHERE tipo = 'Receita'")
        receitas = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM transacoes WHERE tipo = 'Despesa'")
        despesas = cur.fetchone()[0]
        
        # Contar grupos
        cur.execute("SELECT COUNT(DISTINCT grupo) FROM usuarios")
        total_grupos = cur.fetchone()[0]
        
        # Usu√°rios por tipo de base
        cur.execute("SELECT COUNT(*) FROM usuarios WHERE compartilhado = 1")
        compartilhados = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM usuarios WHERE compartilhado = 0")
        separados = cur.fetchone()[0]
        
        conn.close()
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("üë• Total de Usu√°rios", total_usuarios)
            st.metric("üëë Administradores", admins)
            st.metric("üë§ Usu√°rios Comuns", comuns)
            st.metric("üè∑Ô∏è Grupos Distintos", total_grupos)
        
        with col2:
            st.metric("üí∞ Total de Transa√ß√µes", total_transacoes)
            st.metric("üìà Receitas Registradas", receitas)
            st.metric("üìâ Despesas Registradas", despesas)
            st.metric("üîÑ Bases Compartilhadas", compartilhados)
            st.metric("üîí Bases Separadas", separados)

# ---------- Roteamento Principal ----------
def main():
    # Inicializar banco de dados
    auth._verificar_e_atualizar_estrutura_banco()
    
    if not st.session_state.autenticado:
        if st.session_state.pagina_atual == "login":
            pagina_login()
        elif st.session_state.pagina_atual == "alterar_senha":
            pagina_alterar_senha()
    else:
        pagina_principal()

if __name__ == "__main__":
    main()